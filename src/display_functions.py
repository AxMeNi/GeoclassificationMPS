# -*- coding:utf-8 -*-
__projet__ = "GeoclassificationMPS"
__nom_fichier__ = "display_functions"
__author__ = "MENGELLE Axel"
__date__ = "aout 2024"


from sklearn import manifold

import matplotlib.colors as mcolors
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import geone as gn



def plot_realization(deesse_output, varname='', index_real=0, show=False):
    """
    Plot a 2D image of a specific realization from Deesse simulation output.

    This function clears and closes any previous plots, then extracts a specific
    realization from the simulation output and displays it as a 2D image.

    Parameters:
    ----------
    deesse_output : dict
        A dictionary containing the results of a Deesse simulation, where 'sim' holds the simulation realizations as a list or array.
    index_real : int
        The index of the realization to plot within the 'sim' list or array in `deesse_output`.
    varname : str
        The name of the variable being plotted, used in the plot title for context.
    show : bool, optional
        If `True`, the plot is displayed immediately. Default is `True`.

    Returns:
    -------
    None

    Notes:
    -----
    - This function uses `gn.imgplot.drawImage2D` to render the image with categorical values for visualization.
    - Ensure `deesse_output` has been generated by a compatible Deesse simulation, and that `index_real` is a valid index within `deesse_output['sim']`.
    """
    plt.clf()
    plt.close()
    
    sim = deesse_output['sim']
    plt.subplots(1, 1, figsize=(17,10), sharex=True, sharey=True)
    gn.imgplot.drawImage2D(sim[index_real], iv=0, categ=True, title=f'Real #{index_real} {varname}')
    
    if show:
        plt.show()


def plot_mask(mask, background_image=None, alpha=0.5, title=None, show=False):
    """
    Superimpose a binary mask onto a background image and display the results with optional legends and title.

    This function visualizes the background image with a mask applied on top, hiding the values of the 
    background image where the mask is active. The mask is displayed in the specified color, and a title 
    and legends can be added. The mask can also be transparent depending on the `alpha` parameter.

    Parameters:
    ----------
    mask : numpy array
        A binary array representing the mask to overlay on the background image. The mask values should be 
        either 0 or 1, where 1 indicates the presence of the mask.
    background_image : numpy array, optional
        The background image on which the mask will be applied. If `None`, only the mask visualization will be shown.
    mask_color : str, optional
        The color of the overlayed mask. The default is 'white' for the mask. This color must be a valid name 
        in matplotlib color schemes.
    alpha : float, optional
        The transparency level of the overlayed mask. A value between 0 (transparent) and 1 (opaque). 
        The default value is 0.5.
    title : str, optional
        The optional title to display at the top of the image.
    show : bool, optional
        If `True`, displays the plot immediately. Default is `False`.

    Returns:
    -------
    None

    """
    plt.clf()
    plt.close()
    if background_image is not None:
        masked_background = np.ma.masked_where(mask == 1, background_image)
        plt.imshow(masked_background, cmap='gray', label="Background Image")
    
    plt.imshow(mask, cmap='gray', alpha=alpha if background_image is not None else 1, vmin=0, vmax=1, label="Mask")
    
    if title:
        plt.title(title)
    
    background_legend = plt.Line2D([0], [0], color="gray", label="Background Image")
    mask_legend = plt.Line2D([0], [0], color=mask_color, label="Mask", alpha=alpha)
    plt.legend(handles=[background_legend, mask_legend], loc='upper right')
    if show:
        plt.show()


def plot_proportions(sim, show=False):
    """
    Plot category proportions for each of the seven categories in the Mount Isa dataset.

    This function visualizes the proportion of each category across simulation realizations. 
    The function is specific to the Mount Isa dataset and will not work for other datasets 
    due to its assumptions about category values and color schemes.

    Parameters:
    ----------
    sim : list or array
        A collection of simulation realizations to process, each containing categorical data.
    show : bool, optional
        If `True`, displays the plot immediately. Default is `False`.

    Returns:
    -------
    None

    Notes:
    -----
    - This function uses `gn.img.gatherImages` to combine images from the simulation list and 
      `gn.img.imageCategProp` to calculate the proportion of each category.
    - The color scheme is specific to seven categories and should not be modified unless the 
      categorical values or proportions change.
    """
    plt.clf()
    plt.close()
    
    all_sim = gn.img.gatherImages(sim)  
    categ_val = [1,2,3,4,5,6,7]
    
    prop_col = ['lightblue', 'blue', 'orange', 'green', 'red', 'purple', 'yellow']
    cmap = [gn.customcolors.custom_cmap(['white', c]) for c in prop_col]
    
    all_sim_stats = gn.img.imageCategProp(all_sim, categ_val)
    plt.subplots(1, 7, figsize=(17,5), sharey=True)
    
    for i in range(7):
        plt.subplot(1, 7, i+1)
        gn.imgplot.drawImage2D(all_sim_stats, iv=i, cmap=cmap[i],
                               title=f'Prop. of categ. {i}')
    if show:
        plt.show()


def plot_entropy(entropy, background_image=None, categ_var_name=None, show=False):
    """
    Plot a 2D entropy map with an optional categorical background for visual context.

    This function displays a 2D map of entropy values and optionally overlays contours of a categorical variable. 
    If a background image is provided, it adds categorical boundaries on the entropy map and displays the 
    categorical variable in a separate subplot.

    Parameters:
    ----------
    entropy : array-like
        2D array of entropy values to visualize.
    background_image : array-like, optional
        2D array of categorical variable values for overlaying on the entropy plot. Default is `None`.
    categ_var_name : str, optional
        The name of the categorical variable for labeling and titling the background image plot. Default is `None`.
    show : bool, optional
        If `True`, the plot is displayed immediately. Default is `False`.

    Returns:
    -------
    None

    Notes:
    -----
    - If `background_image` is provided, this function displays both the entropy map and the categorical variable 
      with a shared colormap.
    - The categorical variable is shown with unique color-coded values, and contours are drawn over the entropy map.
    """
    plt.clf()
    plt.close()
    ent = np.squeeze(entropy)
    
    if background_image is not None:
        unique_values = np.unique(background_image)
        num_unique = len(unique_values)
        
        cmap = plt.get_cmap('tab20', num_unique)
        
        norm = mcolors.BoundaryNorm(boundaries=np.arange(num_unique+1)-0.5, ncolors=num_unique)
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
        
        ent_img = ax1.imshow(ent, cmap='gray', interpolation='nearest')
        if categ_var_name is not None :
            ax1.set_title(f"Entropy with {categ_var_name} contours")
        else :
            ax1.set_title("Entropy with categorical variable contours")
        
        contour_levels = np.arange(num_unique)
        ax1.contour(background_image, levels=contour_levels, colors='white', linewidths=1)
        
        cbar_entropy = plt.colorbar(ent_img, ax=ax1)
        cbar_entropy.set_label('Entropy')
        
        bg_img = ax2.imshow(background_image, cmap=cmap, norm=norm)
        if categ_var_name is not None :
            ax2.set_title(f'{categ_var_name}')
        else :
            ax2.set_title("Categorical variable")
        
        cbar_bg = plt.colorbar(bg_img, ax=ax2, ticks=np.arange(num_unique))
        cbar_bg.ax.set_yticklabels([str(val) for val in unique_values])

        if categ_var_name is not None :
            cbar_bg.set_label(f'{categ_var_name}')
        else :
            cbar_bg.set_label("Categories")
        
        if categ_var_name is not None :
            plt.suptitle(f'Superposition of entropy with {categ_var_name}')
        else :
            plt.suptitle('Superposition of entropy with categorical variable')
            
        if show:
            plt.tight_layout()
            plt.show()
    
    else:
        plt.figure()
        plt.imshow(ent, cmap='gray', interpolation='nearest')
        plt.colorbar(label='Entropy')
        plt.title("Entropy 2D visualization")
        
        if show:
            plt.tight_layout()
            plt.show()


def plot_histogram_disimilarity(dist_hist, seed, nsim, referenceIsPresent=False, show=False):
    """
    Plots a 2D Multi-Dimensional Scaling (MDS) representation of histogram dissimilarities.

    This function takes a dissimilarity matrix (e.g., derived from Jensen-Shannon divergence between histograms) 
    and performs Multi-Dimensional Scaling (MDS) to reduce the dimensionality to 2D for visualization. 
    The resulting 2D coordinates are plotted, with the points color-coded based on simulation IDs.

    Parameters:
    -----------
    dist_hist : ndarray
        A precomputed dissimilarity matrix (e.g., Jensen-Shannon divergence) of shape (nsim, nsim).
        This matrix represents pairwise dissimilarities between histograms.
    seed : int
        A seed for the random state in the MDS algorithm to ensure reproducibility.
    nsim : int
        Number of simulations. Equivalent to number of points to represent minus the reference.
    referenceIsPresent : bool, optional
        Whether to display a reference point separately.
    show : bool, optional
        If `True`, the plot is displayed immediately. Default is `False`.


    Returns:
    --------
    None. Displays a scatter plot representing the 2D MDS positions of the simulations.

    Notes:
    ------
    - MDS (Multi-Dimensional Scaling) is used to reduce the dimensionality of the dissimilarity matrix to 2D for 
      easier visualization.
    - Colors are assigned to points based on their simulation ID, using a custom colormap that blends blue, green, and red.
    - The function displays the plot but does not return any value.
    """
    plt.clf()
    plt.close()
    #Perform MDS (Multi-Dimensional Scaling) to reduce dimensionality to 2D
    mds = manifold.MDS(n_components=2, max_iter=3000, eps=1e-9, random_state=seed, dissimilarity="precomputed", n_jobs=1)

    mdspos_lc = mds.fit_transform(dist_hist)

    mycmap = plt.get_cmap('tab20', nsim)
    
    s_id = np.arange(nsim)
    
    lcMDSxmin = np.min(mdspos_lc[:, 0])
    lcMDSxmax = np.max(mdspos_lc[:, 0])
    lcMDSymin = np.min(mdspos_lc[:, 1])
    lcMDSymax = np.max(mdspos_lc[:, 1])
    
    s = 100 
    fig, ax = plt.subplots()
    plt.title('2D MDS Representation of hist. dissimilarities')
   
    norm = mcolors.BoundaryNorm(boundaries=np.arange(nsim+1)-0.5, ncolors=nsim)
    if referenceIsPresent:  
        scatter = ax.scatter(mdspos_lc[:-1, 0], mdspos_lc[:-1, 1], c=s_id, cmap=mycmap, s=s, label='lithocode hist', marker='+')
        plt.scatter(mdspos_lc[-1, 0], mdspos_lc[-1, 1], c='red', s=50, label='reference hist', marker='o')
    else:
        scatter = ax.scatter(mdspos_lc[:, 0], mdspos_lc[:, 1], c=s_id, cmap=mycmap, s=s, label='lithocode hist', marker='+')
        
    plt.xlim(lcMDSxmin, lcMDSxmax)
    plt.ylim(lcMDSymin, lcMDSymax)
    plt.legend(scatterpoints=1, loc='best', shadow=False)
    
    cbar = plt.colorbar(scatter, ax=ax, ticks=np.arange(nsim))
    cbar.ax.set_yticklabels([str(val) for val in s_id])
    
    cbar.set_label('simulation #')
    
    if show:
        plt.tight_layout()
        plt.show()


def plot_simvar_histograms(simvar_all, nsim, show=False):
    """
    Plot bar charts of the occurrence counts of each unique simulation variable across multiple simulations.

    This function displays individual bar charts for each unique value of `simvar` within a grid of subplots. 
    Each chart represents the frequency of the `simvar` across simulations, allowing for visual comparison 
    across multiple simulations.

    Parameters:
    ----------
    simvar_all : numpy.ndarray
        4D array where each slice (last dimension) represents a different simulation. The array should 
        contain simulation variables, with NaNs used for any missing values.
    nsim : int
        Total number of simulations to analyze.
    show : bool, optional
        If `True`, the plot is displayed immediately. Default is `False`.

    Returns:
    -------
    None

    Notes:
    -----
    - Each subplot represents one unique simulation variable (`simvar`) across all simulations.
    - `NaN` values are ignored in the computation of counts.
    - The number of columns is fixed to 5, with rows calculated dynamically to fit all unique `simvar` values.
    """
    plt.clf()
    plt.close()
    n_subplots = len(np.unique(simvar_all[~np.isnan(simvar_all)]))  # Number of simvars
    cols = 5  # Adjust the number of columns 
    rows = n_subplots // cols

    if n_subplots % cols != 0:
        rows += 1

    positions = range(1, n_subplots + 1) 

    fig = plt.figure(figsize=(cols * 3, rows * 3))  # Each subplot will be of size 3x3

    unique_simvars = np.unique(simvar_all[~np.isnan(simvar_all)])
    
    # For each simvar
    for k, simvar in enumerate(unique_simvars):
        ax = fig.add_subplot(rows, cols, positions[k])
        
        simvar_counts = []
        
        # For each simulation
        for i in range(nsim):
            simvar_i = simvar_all[:, :, :, i].flatten()
            simvar_i = simvar_i[~np.isnan(simvar_i)]
            count = np.sum(simvar_i == simvar)
            simvar_counts.append(count)
            
        ax.bar(range(nsim), simvar_counts, color='blue', label=f'simvar {simvar}')

        ax.set_title(f'simvar {simvar}')
        ax.set_xlabel(f'Simulations')
        ax.tick_params(axis='both', which='major', labelsize=6)
        
    plt.subplots_adjust(left=0.1, right=0.9, top=0.9, bottom=0.1, hspace=0.4, wspace=0.3)
    
    if show:
        plt.tight_layout()
        plt.show()


def plot_topological_adjacency(dist_hist, dist_topo_hamming, nsim, referenceIsPresent=False, show=False):
    """
    Plot a 2D MDS (Multidimensional Scaling) representation of the topological adjacency among simulations, 
    based on Hamming distance. 

    This function visualizes the relative positions of simulations in 2D space, highlighting the relationships 
    based on topological adjacency. If a reference simulation is present, it is represented by a red circular 
    marker, while other simulations are represented by 'x' markers.

    Parameters:
    ----------
    dist_hist : numpy.ndarray
        A distance matrix that stores pairwise distances between simulations for the histogram-based measure.
    dist_topo_hamming : numpy.ndarray
        A distance matrix that stores pairwise Hamming distances between simulations based on topological adjacency.
    nsim : int
        Total number of simulations.
    referenceIsPresent : bool, optional
        If `True`, the last simulation is treated as a reference and is displayed differently in the plot. 
        Default is `False`.
    show : bool, optional
        If `True`, the plot is displayed immediately. Default is `False`.

    Returns:
    -------
    None

    Notes:
    -----
    - This plot relies on a random initialization of the 2D MDS positions, seeded for reproducibility.
    - Each simulation is colored using a categorical colormap to distinguish between different simulations.
    - When `referenceIsPresent` is `True`, the reference is displayed with a circular red marker for clarity.
    - The color bar displays simulation IDs.
    """
    plt.clf()
    plt.close()
    
    np.random.seed(852)
    mdspos_lc = np.random.rand(nsim, 2)  # Simulated MDS positions for simvars
    s_id = np.arange(nsim)
       
    mycmap = plt.get_cmap('tab20', nsim)
    norm = mcolors.BoundaryNorm(boundaries=np.arange(nsim+1)-0.5, ncolors=nsim)
    
    ix = np.tril_indices(nsim, k=-1)
    dist_hist_vals = dist_hist[ix]
    dist_topo_hamming_vals = dist_topo_hamming[ix]
    
    lcmin, lcmax = np.min(dist_hist_vals), np.max(dist_hist_vals)
    sfmin, sfmax = np.min(dist_topo_hamming_vals), np.max(dist_topo_hamming_vals)
    
    s = 100
    plt.title('2D MDS Representation of Topological Adjacency (Hamming)')
    
    if referenceIsPresent:
        scatter = plt.scatter(mdspos_lc[:-1, 0], mdspos_lc[:-1, 1], c=s_id[:-1], cmap=mycmap, s=s, label='Scalar field Hamming', marker='x')
        plt.scatter(mdspos_lc[-1, 0], mdspos_lc[-1, 1], c='red', s=50, label='reference Hamming', marker='o')
    else:
        scatter = plt.scatter(mdspos_lc[:, 0], mdspos_lc[:, 1], c=s_id, cmap=mycmap, s=s, label='Scalar field Hamming', marker='x')
        
    plt.xlim(np.min(mdspos_lc[:, 0]), np.max(mdspos_lc[:, 0]))
    plt.ylim(np.min(mdspos_lc[:, 1]), np.max(mdspos_lc[:, 1]))
    plt.legend(scatterpoints=1, loc='best', shadow=False)
    
    cbar = plt.colorbar(scatter, ticks=np.arange(nsim))
    cbar.ax.set_yticklabels([str(val) for val in s_id])  # Label the ticks with sample IDs
    cbar.set_label('Simulation #')
    
    if show:
        plt.tight_layout()
        plt.show()


def plot_standard_deviation(std_array, realizations_range, indicator_name, show=False):
    plt.figure(figsize=(15, 5))
    #Jensen-Shannon Divergence, Entropy, Topological Adjacency
    plt.plot(realizations_range, std_array, marker='o', color='blue')
    plt.title(f'Standard Deviation of {indicator_name}')
    plt.xlabel('Number of Realizations')
    plt.ylabel('Standard Deviation')
        
    plt.tight_layout()
    if show:
        plt.show()
    
